###空间代价

 - 时间代价是相对于处理某个数据结构的**算法**而言的，而空间代价是相对于数据结构本身而言的。
 > 例1：一个包含n个整数的一维数组空间代价为多少？
 如果每个整数占用c字节，则整个数组需要cn字节的空间，即O(n).

 > 例2：假设要记录n个人互相之间的朋友关系，就可以用一个n*n的数组来实现。数组的每一行表示某人的所有朋友，每一列则显示谁是朋友。
 对于n个人来说，数组总规模为O(n^2).
 
 - 一个数据结构的主要目的是用恰当的方法存储数据，使我们能够简单而有效地对其进行访问。为此，必须在这个数据结构中加上一些附加信息，指明数据存放在何处（例如，链表的每个元素都带有一个指针，指向表中的下一个元素）。所有这类并非真正数据的附加信息称为**结构性开销（overhead）**。
 > 理论上，这种结构性开销应该尽量小，而访问路径又应该尽可能多且有效。这种相互矛盾的目标之间的权衡正是研究数据结构的乐趣和魅力所在。
 
 - 算法设计有一个重要原则，即**空间/时间权衡原则（space/time tradeoff）**。
> 例3：查找表（lookup table）中预先存放了一些函数值，从而不必每次调用时都重新计算。
> 例如阶乘函数，如果使用32位的int型变量来存储，则12！是允许范围内的最大函数值。如果一个程序中需要多次重复计算阶乘，那么把这12个函数值预先存放在一个查找表中将会大大减少运行时间。程序需要n！（n<12）的值时，只要简单查一下查找表就行了。与每次计算阶乘的时间代价相比，牺牲一点点空间来存放查找表很值得。
> 查找表的另一个用途是存放某些具有较大开销的函数的近似值，如sin，cos等。

 - 程序空间、时间代价相互关系的另一个原则是对处理存储在磁盘上的信息（外存信息）而言的。有意思的是，**基于磁盘的空间/时间权衡原则（disk-based space/time tradeoff）**与上面所说的空间/时间权衡原则几乎是完全相反的。基于磁盘的空间/时间权衡原则为：**在磁盘上的存储代价越小，程序运行得越快**。
 > 这是因为从磁盘上读取数据的时间代价远远大于用于计算的时间代价，于是几乎所有用于对数据进行解压缩的额外操作的时间代价，都小于减少存储代价后节约下来的读盘时间。
 
 - 一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。　
（1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于**静态空间**。
（2）可变空间，这部分空间的主要包括**动态分配**的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。
一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))，其中n为问题的规模，S(n)表示空间复杂度。


----------
###参考资料

[1]《数据结构与算法分析（C++版）》（第二版）. [美]  Clifford A. Shaffer著.
[2][《时间复杂度和空间复杂度详解》](http://blog.csdn.net/booirror/article/details/7707551/)